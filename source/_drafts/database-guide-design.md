title: 关系型数据库开发简明教程(3)——数据库设计及ER图
tags:
---

今天的文章我们将会对如何进行数据库设计及相关的工具进行一个简要介绍。数据库设计包含的内容其实很多，包括表及表间关系的设计、索引的设计等等。那我主要介绍如何进行表及表间关系的设计。

# 范式及反范式

提到数据库设计，就不得不提数据库设计的范式。范式（Normal Form）是符合某一种级别的关系模式的集合。要想设计一个结构合理的关系型数据库，就需要满足一定的范式。满足高等级的范式必须先满足低等级的范式（比如：满足2NF就一定满足1NF，满足3NF就一定满足2NF和1NF）。目前，关系数据库有六种范式。一般来说，数据库满足到第三范式就可以减少数据冗余，消除插入、更新、删除异常了，基本能够满足实际需求了。实际使用过程中，在具体的情况下，甚至会有违反范式的设计存在。

数据库设计的范式在学术上的定义十分晦涩，很不好理解，下面我尽量用通俗易懂的语言并结合实际例子来对数据库设计的三大范式进行一个简要的介绍。

我们使用下面这张表作为示例表：

![sample table](http://chuantu.biz/t2/13/1443010488x-954497580.png)

表的各个字段应该很清除了，有2个主键，分别是工号（empId）和部门名称（depName）。

## 第一范式（1NF）

1NF要求表的每个字段不可再分。很明显，我们的示例表中的address字段不是不可再分了，还可以继续分解为省、市。

但是，为啥要进行分解啊？理由如下：

  - 数据冗余。“浙江省杭州市”、“贵州省毕节市”在表中出现了多次，如果“浙江省”要改名（当然可能不太会发生），需要每行都去进行更新。
  - 查询不方便。如果我们需要找出所有浙江省的员工或是所有南京市的员工，那唯一的办法只能对address字段进行字符串匹配，查询不够高效。

解决方法就是将地址单独进行分解，于是表调整为如下：

![1nf table](http://chuantu.biz/t2/13/1443012320x-1376440181.png)

这样以后，我们解决了地址的冗余数据，地址更新只要单独更新address表即可，并且查询起来也很方便（使用后面文章将要介绍的JOIN查询）。

## 第二范式（2NF）

满足1NF，并且表中字段完全依赖于全部主键，而不是部分主键。所以，只有一个主键的表，如果符合了1NF，那就一定符合2NF。

我们看看我们的表，depDesc（部门描述）只由depName（部门名称）决定（depName一旦确定，depDesc就唯一确定），不由empId（工号）确定（empId确定，depDesc并不是唯一确定的，比如：工号1时depDesc是技术部门，工号2时depDesc还是技术部门）。所以，这是一种部分依赖，2NF就是要消除这种部分依赖。

但是，为啥要消除啊？理由如下：

  - 数据冗余。相同的部门信息在各个数据记录里重复出现。
  - 插入异常。假设现在突然决定增加一个部门，但是部门里面还没开始招人，由于主键empId为空，部门数据根本无法插入到表里。
  - 删除异常。假设现在技术部这个部门不再存在，需要删除，会造成相关的员工信息（张三和李四）也被删除了。
  - 更新异常。假设现在技术部需要更名为前端技术部，需要同时更新多条记录，极易出错。

解决方法还是进行分解，于是表调整为如下：

![2nf talbe](http://chuantu.biz/t2/13/1443014117x-954498822.png)

我们再来看看，前面的问题有改善吗？

  - 数据冗余。部门进行单独记录了，没有重复出现。
  - 插入异常。部门单独放在一张表里，可以随意添加。
  - 删除异常。部门单独放在一张表里，直接删除相关记录即可。
  - 更新异常。部门单独放在一张表里，直接进行更新即可。

## 第三范式（3NF）

满足2NF，并且除主键以外的所有字段不能互相依赖。

我们看我们的表，jobDesc（岗位描述）是由job（岗位）决定的，这产生了除主键以外的依赖。所以，我们必须再进行一次拆分。

但是，为啥要拆分啊？理由如下：

  - 数据冗余。岗位的数据在多个记录里重复出现。
  - 插入异常。假设现在需要增加一个岗位，但是这个岗位还没开始招人，由于主键empId为空，岗位无法插入。
  - 删除异常。假设现在我们不要所有的交互设计师了，需要删除，相关的员工信息一起被删除了。
  - 更新异常。假设现在需要更新交互设计师的岗位描述，需要同时更新多条记录。

经过拆分，表调整为如下：

![3nf table](http://chuantu.biz/t2/13/1443015143x-954498822.png)

我们再来看看，前面的问题是否解决？

  - 数据冗余。岗位数据单独记录，没有冗余。
  - 插入异常。岗位单独记录，可以随意进行添加。
  - 删除异常。岗位单独记录，直接删除相关记录即可，不影响员工信息。
  - 更新异常。岗位单独记录，直接更新即可。

## 反范式

到了3NF通常已经能够满足业务需求，表之间的结构也清晰，不会产生数据冗余，也不会发生插入、删除、更新异常，容易维护。但是有时候我们却需要反范式又是为什么呢？

可以看到，范式等级越高，表越多。这带来的问题是，查询需要连接多个表，当表数据量很大的时候，会增加查询的复杂度，降低查询性能，严重的甚至造成“锁库”，影响数据库的吞吐量。

要知道，范式理论产生和完善的时间（20世纪80年代），存储资源非常有限，几百M的磁盘就算大的了，另外，当时网络不是很成熟，使用网络的人比较少，主要还是涉及单机的计算性能。所以，范式强调减少依赖、降低冗余（减少存储量）是非常合理的。而现在，存储简直“不值钱”，动不动几百G，甚至上T，而且应用更强调高并发、低延迟，如果还一味循规蹈矩是不太合适的。所以，我们可以适当降低范式，增加冗余，用空间来换取时间。

一般在各种统计报表中，就经常使用冗余表，定时将各个分表的数据dump到一张大表中，再对大表进行各种查询、统计、分析来提高性能。

# ER（Entity Relationship）设计

实际上，为了说明问题，上面的示例表比较极端。就我个人感受来说，如果我们仔细理清表及表间关系，基本上都是符合3NF的设计。我们接下来就开始介绍ER图及ER设计。主要使用的工具是MySQL Workbench，大家可以到这里进行下载安装：<https://www.mysql.com/products/workbench/>。

## 基本概念

首先，我们需要理解一些概念。

  - 实体（Entity）：现实世界中客观存在的“事物”，可以和面向对象设计中的类进行类比，但是这里的“事物”还可以是一种虚拟的关系（比如：用户和自己所写的笔记）。实体会映射为数据库中的表。
  - 属性（Property）：实体所具有的“特性”，可以和面向对象设计中类的属性进行类比。属性会映射为数据库中表的字段。
  - 关系（Relation）：表示实体和实体之间的关系，包括：一对一、一对多、多对多。多对多关系一般会映射为单独的关系实体。
  - 外键（Foreign Key）：表中的某一列，其值是另一个表的主键值，定义了两个表之间的关系。

另外，需要说明的是，MySQL Workbench中提供的ER工具实际上画出的是EER图（Extended Entity Relationship），而不是标准意义上的ER图，EER图更加接近于数据库中的表示（实际上是一种ER+物理表示的结合），用起来也比较简单清晰。

## 快速开始

打开MySQL Workbench后，下方会出现Models区域，点击"+"按钮，新建一个建模空间。接着点击"Add Diagram"来新建一改ERR图。效果如图：

![new model](http://pic.sueri.cn/di-4MAO.png)

![new eer](http://pic.sueri.cn/di-VBNX.png)

![eer](http://pic.sueri.cn/di-QDQL.png)

## 单实体设计

单实体设计需要考虑清楚此实体需要具备哪些属性，这些属性具有哪些性质（不能为空、唯一、长等等），使用何种数据类型进行存储。可以和我们之前介绍过的建表部分联系起来。

在MySQL Workbench中进行设计很方便，将表放置到画布中后，双击表即可对表字段进行各种设计。如图所示：

![new table](http://pic.sueri.cn/di-ZUSO.png)

## 关系设计

事物毕竟都是互相关联的，关系设计就需要理清实体之间的关系。一般来说，主要分为：一对一、一对多、多对多。MySQL Workbench中还会派生出关系是否必须，关系是不是identifying的，非常晦涩，不好理解。

在开始对关系进行详细介绍前，我们先简单说明下Identifying Relationship的含义。实际应用时我基本上没用过这种关系，为了完整，这里只做个简单介绍。

关系的产生通常都是通过外键来进行关联，Identifying关系中，这个外键同时也是表的主键，从而和表本身的主键形成了一个“复合主键“（Composite Primary Key），2个列共同组合起来标志表的唯一一条记录。

比如下面的这样一张表：

```sql
CREATE TABLE `test` (
  `id` int(11) NOT NULL,
  `fk_id` int(11) NOT NULL,
  PRIMARY KEY (`id`,`fk_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

就是一个含有复合主键`(id, fk_id)`的表，在表中可以存在(1, 1)，(2, 1)这样的记录时，就不可能再插入(1, 1)和(2, 1)记录了。复合主键一般用在多对多关系中的关系表。

### 一对一关系

一对一关系的含义是：实体A拥有一个实体B（可以不拥有），实体B唯一属于一个实体A（可以不属于）。比如：用户可以拥有一个账户（也可以不拥有账户），但是不会同时拥有多个账户；一个账户属于一个用户（也可以不属于），但是不会同时属于多个用户。

需要实现一对一的关联，必然要在用户表或者账户表的其中之一添加一个“外键”来做关联。添加到用户表或者账户表都是可以的，有几个问题需要我们考虑。

  - 如果要保证“绝对”的一对一关系，外键应该设置成`UNIQUE`（不允许重复）
  - 如果关系不是必须的，外键应该设置成`NOT NULL`

我更喜欢将外键添加到账户表中，表示一种“属于”的含义，和一对多“一脉相承”（这在我们后面的系列文章中将看到更详细的解释）。

### 一对多关系

一对多关系的含义是：实体A拥有一个或多个实体B（可以不拥有），实体B唯一属于一个实体A（可以不属于）。比如：用户可以拥有一个或多个记事本（也可以不拥有），一个记事本属于一个用户（也可以不属于），但是不会同时属于多个用户。

需要实现一对多关系，外键应该添加到多的一端（即记事本表）。为啥不能添加到用户表啊？因为，用户表当中不能插入主键相同的用户数据，没法表现出多的关系。所以，实际上一对多关系就是在一对一的关系中去掉外键的UNIQUE性质。同样，和上面的例子一样，如果关系不是必须的，外键应该设置成`NOT NULL`。

### 多对多关系

多对多关系的含义是：实体A拥有一个或多个实体B，实体B属于一个或多个实体B。比如：标签拥有一个或多个记事本，标签



